    N = X.shape[0]
    D = X.shape[1]
    M = p_x_1_y.shape[0]
    p_y_x = np.ones(shape=(N, M))
    p_x_0_y = np.zeros(shape=(M, D))
    logical_not = np.ones(shape=(1, D))
    x_row = np.zeros(shape=(1, D))
    for m in range(M):
        for d in range(D):
            p_x_0_y[m, d] = 1 - p_x_1_y[m, d]
    for n in range(0, N):
        divisor = 0
        x_row = X[n, :]
        for m in range(0, M):
            tmp = np.multiply(x_row, p_x_1_y[m, :])
            p_y_x[n, m] = np.prod(tmp)
            x_row = (logical_not - x_row)
            tmp = x_row * p_x_0_y[m, :]
        tmp = np.place(tmp, tmp == 0, 1)
        p_y_x[n, m] *= np.prod(tmp)
        divisor += (p_y_x[n, m] * p_y[m])
        for m in range(0, M):
            p_y_x[n, m] = (p_y_x[n, m] * p_y[m]) / divisor

    return p_y_x